(* bridge_js -- GENERATED by generate_bridge_js.py *)
(* Do not edit this file -- edit src/bridge.js instead *)

#include "share/atspre_staload.hats"

staload "./lib.sats"

$UNSAFE begin
%{
static const char *_bridge_js_source(void);
%}
end

extern fun _bridge_js_source(): string = "mac#_bridge_js_source"

implement produce_bridge() = _bridge_js_source()

$UNSAFE begin
%{$
static const char *_bridge_js_source(void) {
  return
"// bats_bridge.mjs — Bridge between bats WASM and a DOM document\n"
"// Parses the bats binary diff protocol and applies it to a standard DOM.\n"
"// Works in any ES module environment (browser or Node.js).\n"
"\n"
"// Parse a little-endian i32 from a Uint8Array at offset\n"
"function readI32(buf, off) {\n"
"  return buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24);\n"
"}\n"
"\n"
"/**\n"
" * Load a bats WASM module and connect it to a DOM document.\n"
" *\n"
" * @param {BufferSource} wasmBytes — compiled WASM bytes\n"
" * @param {Element} root — root element for bats to render into (node_id 0)\n"
" * @returns {{ exports, nodes, done }} — WASM exports, node registry,\n"
" *   and a promise that resolves when WASM calls bats_exit\n"
" */\n"
"export async function loadWASM(wasmBytes, root, opts) {\n"
"  const extraImports = (opts && opts.extraImports) || {};\n"
"  const document = root.ownerDocument;\n"
"  let instance = null;\n"
"  let resolveDone;\n"
"  const done = new Promise(r => { resolveDone = r; });\n"
"\n"
"  // Node registry: node_id -> DOM element\n"
"  const nodes = new Map();\n"
"  nodes.set(0, root);\n"
"\n"
"  function readBytes(ptr, len) {\n"
"    return new Uint8Array(instance.exports.memory.buffer, ptr, len).slice();\n"
"  }\n"
"\n"
"  function readString(ptr, len) {\n"
"    return new TextDecoder().decode(readBytes(ptr, len));\n"
"  }\n"
"\n"
"  // JS-side data stash — WASM pulls data via bats_js_stash_read\n"
"  const dataStash = new Map();\n"
"  let nextStashId = 0;\n"
"\n"
"  function stashData(data) {\n"
"    const id = nextStashId++;\n"
"    dataStash.set(id, data);\n"
"    return id;\n"
"  }\n"
"\n"
"  function batsJsStashRead(stashId, destPtr, len) {\n"
"    const data = dataStash.get(stashId);\n"
"    if (data) {\n"
"      const copyLen = Math.min(len, data.length);\n"
"      new Uint8Array(instance.exports.memory.buffer).set(\n"
"        data.subarray(0, copyLen), destPtr);\n"
"      dataStash.delete(stashId);\n"
"    }\n"
"  }\n"
"\n"
"  // Blob URL lifecycle tracking — revoked when element gets new image or is removed\n"
"  const blobUrls = new Map();\n"
"\n"
"  // --- DOM helpers ---\n"
"\n"
"  // Remove all descendant entries from `nodes` and revoke their blob URLs.\n"
"  // Called before clearing or removing an element that may have registered children.\n"
"  function cleanDescendants(parentEl) {\n"
"    for (const [id, node] of nodes) {\n"
"      if (id !== 0 && node !== parentEl && parentEl.contains(node)) {\n"
"        const oldUrl = blobUrls.get(id);\n"
"        if (oldUrl) { URL.revokeObjectURL(oldUrl); blobUrls.delete(id); }\n"
"        nodes.delete(id);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  // --- DOM flush ---\n"
"\n"
"  function batsDomFlush(bufPtr, len) {\n"
"    const mem = new Uint8Array(instance.exports.memory.buffer);\n"
"    let pos = 0;\n"
"\n"
"    while (pos < len) {\n"
"      const op = mem[bufPtr + pos];\n"
"      const nodeId = readI32(mem, bufPtr + pos + 1);\n"
"\n"
"      switch (op) {\n"
"        case 4: { // CREATE_ELEMENT\n"
"          const parentId = readI32(mem, bufPtr + pos + 5);\n"
"          const tagLen = mem[bufPtr + pos + 9];\n"
"          const tag = new TextDecoder().decode(mem.slice(bufPtr + pos + 10, bufPtr + pos + 10 + tagLen));\n"
"          const el = document.createElement(tag);\n"
"          nodes.set(nodeId, el);\n"
"          const parent = nodes.get(parentId);\n"
"          if (parent) parent.appendChild(el);\n"
"          pos += 10 + tagLen;\n"
"          break;\n"
"        }\n"
"        case 1: { // SET_TEXT\n"
"          const textLen = mem[bufPtr + pos + 5] | (mem[bufPtr + pos + 6] << 8);\n"
"          const text = new TextDecoder().decode(mem.slice(bufPtr + pos + 7, bufPtr + pos + 7 + textLen));\n"
"          const el = nodes.get(nodeId);\n"
"          if (el) el.textContent = text;\n"
"          pos += 7 + textLen;\n"
"          break;\n"
"        }\n"
"        case 2: { // SET_ATTR\n"
"          const nameLen = mem[bufPtr + pos + 5];\n"
"          const name = new TextDecoder().decode(mem.slice(bufPtr + pos + 6, bufPtr + pos + 6 + nameLen));\n"
"          const valOff = pos + 6 + nameLen;\n"
"          const valLen = mem[bufPtr + valOff] | (mem[bufPtr + valOff + 1] << 8);\n"
"          const value = new TextDecoder().decode(mem.slice(bufPtr + valOff + 2, bufPtr + valOff + 2 + valLen));\n"
"          const el = nodes.get(nodeId);\n"
"          if (el) el.setAttribute(name, value);\n"
"          pos += 6 + nameLen + 2 + valLen;\n"
"          break;\n"
"        }\n"
"        case 3: { // REMOVE_CHILDREN\n"
"          const el = nodes.get(nodeId);\n"
"          if (el) {\n"
"            cleanDescendants(el);\n"
"            el.innerHTML = '';\n"
"          }\n"
"          pos += 5;\n"
"          break;\n"
"        }\n"
"        case 5: { // REMOVE_CHILD\n"
"          const el = nodes.get(nodeId);\n"
"          if (el) {\n"
"            cleanDescendants(el);\n"
"            el.remove();\n"
"          }\n"
"          const oldUrl = blobUrls.get(nodeId);\n"
"          if (oldUrl) { URL.revokeObjectURL(oldUrl); blobUrls.delete(nodeId); }\n"
"          nodes.delete(nodeId);\n"
"          pos += 5;\n"
"          break;\n"
"        }\n"
"        default:\n"
"          throw new Error(`Unknown bats DOM op: ${op} at offset ${pos}`);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  // --- Image src (direct bridge call, not diff buffer) ---\n"
"\n"
"  function batsJsSetImageSrc(nodeId, dataPtr, dataLen, mimePtr, mimeLen) {\n"
"    const mime = readString(mimePtr, mimeLen);\n"
"    const bytes = readBytes(dataPtr, dataLen);\n"
"    const oldUrl = blobUrls.get(nodeId);\n"
"    if (oldUrl) URL.revokeObjectURL(oldUrl);\n"
"    const blob = new Blob([bytes], { type: mime });\n"
"    const url = URL.createObjectURL(blob);\n"
"    const el = nodes.get(nodeId);\n"
"    if (el) el.src = url;\n"
"    blobUrls.set(nodeId, url);\n"
"  }\n"
"\n"
"  // --- Timer ---\n"
"\n"
"  function batsSetTimer(delayMs, resolverId) {\n"
"    setTimeout(() => {\n"
"      instance.exports.bats_timer_fire(resolverId);\n"
"    }, delayMs);\n"
"  }\n"
"\n"
"  // --- IndexedDB ---\n"
"\n"
"  let dbPromise = null;\n"
"  function openDB() {\n"
"    if (!dbPromise) {\n"
"      dbPromise = new Promise((resolve, reject) => {\n"
"        const req = indexedDB.open('bats', 1);\n"
"        req.onupgradeneeded = () => {\n"
"          req.result.createObjectStore('kv');\n"
"        };\n"
"        req.onsuccess = () => resolve(req.result);\n"
"        req.onerror = () => reject(req.error);\n"
"      });\n"
"    }\n"
"    return dbPromise;\n"
"  }\n"
"\n"
"  function batsIdbPut(keyPtr, keyLen, valPtr, valLen, resolverId) {\n"
"    const key = readString(keyPtr, keyLen);\n"
"    const val = readBytes(valPtr, valLen);\n"
"    openDB().then(db => {\n"
"      const tx = db.transaction('kv', 'readwrite');\n"
"      tx.objectStore('kv').put(val, key);\n"
"      tx.oncomplete = () => {\n"
"        instance.exports.bats_idb_fire(resolverId, 0);\n"
"      };\n"
"      tx.onerror = () => {\n"
"        instance.exports.bats_idb_fire(resolverId, -1);\n"
"      };\n"
"    });\n"
"  }\n"
"\n"
"  function batsIdbGet(keyPtr, keyLen, resolverId) {\n"
"    const key = readString(keyPtr, keyLen);\n"
"    openDB().then(db => {\n"
"      const tx = db.transaction('kv', 'readonly');\n"
"      const req = tx.objectStore('kv').get(key);\n"
"      req.onsuccess = () => {\n"
"        const result = req.result;\n"
"        if (result === undefined) {\n"
"          instance.exports.bats_idb_fire_get(resolverId, 0);\n"
"        } else {\n"
"          const data = new Uint8Array(result);\n"
"          const stashId = stashData(data);\n"
"          instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"          instance.exports.bats_idb_fire_get(resolverId, data.length);\n"
"        }\n"
"      };\n"
"      req.onerror = () => {\n"
"        instance.exports.bats_idb_fire_get(resolverId, 0);\n"
"      };\n"
"    });\n"
"  }\n"
"\n"
"  function batsIdbDelete(keyPtr, keyLen, resolverId) {\n"
"    const key = readString(keyPtr, keyLen);\n"
"    openDB().then(db => {\n"
"      const tx = db.transaction('kv', 'readwrite');\n"
"      tx.objectStore('kv').delete(key);\n"
"      tx.oncomplete = () => {\n"
"        instance.exports.bats_idb_fire(resolverId, 0);\n"
"      };\n"
"      tx.onerror = () => {\n"
"        instance.exports.bats_idb_fire(resolverId, -1);\n"
"      };\n"
"    });\n"
"  }\n"
"\n"
"  // --- Window ---\n"
"\n"
"  function batsJsFocusWindow() {\n"
"    try { root.ownerDocument.defaultView.focus(); } catch(e) {}\n"
"  }\n"
"\n"
"  function batsJsGetVisibilityState() {\n"
"    try {\n"
"      return document.visibilityState === 'hidden' ? 1 : 0;\n"
"    } catch(e) { return 0; }\n"
"  }\n"
"\n"
"  function batsJsLog(level, msgPtr, msgLen) {\n"
"    const msg = readString(msgPtr, msgLen);\n"
"    const labels = ['debug', 'info', 'warn', 'error'];\n"
"    const label = labels[level] || 'log';\n"
"    console.log(`[bats:${label}] ${msg}`);\n"
"  }\n"
"\n"
"  // --- Navigation ---\n"
"\n"
"  function writeStringToWasm(str, outPtr, maxLen) {\n"
"    const encoded = new TextEncoder().encode(str);\n"
"    const len = Math.min(encoded.length, maxLen);\n"
"    new Uint8Array(instance.exports.memory.buffer).set(encoded.subarray(0, len), outPtr);\n"
"    return len;\n"
"  }\n"
"\n"
"  function batsJsGetUrl(outPtr, maxLen) {\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      return writeStringToWasm(win.location.href, outPtr, maxLen);\n"
"    } catch(e) { return 0; }\n"
"  }\n"
"\n"
"  function batsJsGetUrlHash(outPtr, maxLen) {\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      return writeStringToWasm(win.location.hash, outPtr, maxLen);\n"
"    } catch(e) { return 0; }\n"
"  }\n"
"\n"
"  function batsJsSetUrlHash(hashPtr, hashLen) {\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      win.location.hash = readString(hashPtr, hashLen);\n"
"    } catch(e) {}\n"
"  }\n"
"\n"
"  function batsJsReplaceState(urlPtr, urlLen) {\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      win.history.replaceState(null, '', readString(urlPtr, urlLen));\n"
"    } catch(e) {}\n"
"  }\n"
"\n"
"  function batsJsPushState(urlPtr, urlLen) {\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      win.history.pushState(null, '', readString(urlPtr, urlLen));\n"
"    } catch(e) {}\n"
"  }\n"
"\n"
"  // --- DOM read ---\n"
"\n"
"  function batsJsMeasureNode(nodeId) {\n"
"    const el = nodes.get(nodeId);\n"
"    if (el && typeof el.getBoundingClientRect === 'function') {\n"
"      const rect = el.getBoundingClientRect();\n"
"      instance.exports.bats_measure_set(0, Math.round(rect.x));\n"
"      instance.exports.bats_measure_set(1, Math.round(rect.y));\n"
"      instance.exports.bats_measure_set(2, Math.round(rect.width));\n"
"      instance.exports.bats_measure_set(3, Math.round(rect.height));\n"
"      instance.exports.bats_measure_set(4, el.scrollWidth || 0);\n"
"      instance.exports.bats_measure_set(5, el.scrollHeight || 0);\n"
"      return 1;\n"
"    }\n"
"    for (let i = 0; i < 6; i++) {\n"
"      instance.exports.bats_measure_set(i, 0);\n"
"    }\n"
"    return 0;\n"
"  }\n"
"\n"
"  function batsJsQuerySelector(selectorPtr, selectorLen) {\n"
"    const selector = readString(selectorPtr, selectorLen);\n"
"    try {\n"
"      const el = document.querySelector(selector);\n"
"      if (!el) return -1;\n"
"      for (const [id, node] of nodes) {\n"
"        if (node === el) return id;\n"
"      }\n"
"      return -1;\n"
"    } catch(e) { return -1; }\n"
"  }\n"
"\n"
"  // --- Event listener ---\n"
"\n"
"  const listenerMap = new Map();\n"
"  let currentEvent = null;\n"
"\n"
"  // Encode event payload as binary (little-endian).\n"
"  // Returns Uint8Array or null for no payload.\n"
"  function encodeEventPayload(event, eventType) {\n"
"    if (eventType === 'click' || eventType === 'pointerdown' ||\n"
"        eventType === 'pointerup' || eventType === 'pointermove') {\n"
"      // [f64:clientX] [f64:clientY] [i32:target_node_id]\n"
"      const buf = new ArrayBuffer(20);\n"
"      const dv = new DataView(buf);\n"
"      dv.setFloat64(0, event.clientX || 0, true);\n"
"      dv.setFloat64(8, event.clientY || 0, true);\n"
"      let targetId = -1;\n"
"      if (event.target) {\n"
"        for (const [id, node] of nodes) {\n"
"          if (node === event.target) { targetId = id; break; }\n"
"        }\n"
"      }\n"
"      dv.setInt32(16, targetId, true);\n"
"      return new Uint8Array(buf);\n"
"    }\n"
"    if (eventType === 'keydown' || eventType === 'keyup') {\n"
"      // [u8:keyLen] [bytes:key] [u8:flags]\n"
"      const key = event.key || '';\n"
"      const keyBytes = new TextEncoder().encode(key);\n"
"      const buf = new Uint8Array(1 + keyBytes.length + 1);\n"
"      buf[0] = keyBytes.length;\n"
"      buf.set(keyBytes, 1);\n"
"      const flags = (event.shiftKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) |\n"
"                    (event.altKey ? 4 : 0) | (event.metaKey ? 8 : 0);\n"
"      buf[1 + keyBytes.length] = flags;\n"
"      return buf;\n"
"    }\n"
"    if (eventType === 'input') {\n"
"      // [u16le:value_len] [bytes:value]\n"
"      const value = (event.target && event.target.value) || '';\n"
"      const valBytes = new TextEncoder().encode(value);\n"
"      const buf = new Uint8Array(2 + valBytes.length);\n"
"      buf[0] = valBytes.length & 0xFF;\n"
"      buf[1] = (valBytes.length >> 8) & 0xFF;\n"
"      buf.set(valBytes, 2);\n"
"      return buf;\n"
"    }\n"
"    if (eventType === 'scroll') {\n"
"      // [f64:scrollTop] [f64:scrollLeft]\n"
"      const buf = new ArrayBuffer(16);\n"
"      const dv = new DataView(buf);\n"
"      const target = event.target || {};\n"
"      dv.setFloat64(0, target.scrollTop || 0, true);\n"
"      dv.setFloat64(8, target.scrollLeft || 0, true);\n"
"      return new Uint8Array(buf);\n"
"    }\n"
"    if (eventType === 'resize') {\n"
"      // [f64:width] [f64:height]\n"
"      const buf = new ArrayBuffer(16);\n"
"      const dv = new DataView(buf);\n"
"      const win = root.ownerDocument.defaultView || {};\n"
"      dv.setFloat64(0, win.innerWidth || 0, true);\n"
"      dv.setFloat64(8, win.innerHeight || 0, true);\n"
"      return new Uint8Array(buf);\n"
"    }\n"
"    if (eventType === 'touchstart' || eventType === 'touchend' || eventType === 'touchmove') {\n"
"      // [f64:clientX] [f64:clientY] [i32:identifier]\n"
"      const touch = (event.touches && event.touches[0]) ||\n"
"                    (event.changedTouches && event.changedTouches[0]);\n"
"      if (touch) {\n"
"        const buf = new ArrayBuffer(20);\n"
"        const dv = new DataView(buf);\n"
"        dv.setFloat64(0, touch.clientX || 0, true);\n"
"        dv.setFloat64(8, touch.clientY || 0, true);\n"
"        dv.setInt32(16, touch.identifier || 0, true);\n"
"        return new Uint8Array(buf);\n"
"      }\n"
"      return null;\n"
"    }\n"
"    if (eventType === 'visibilitychange') {\n"
"      // [u8:hidden]\n"
"      return new Uint8Array([document.visibilityState === 'hidden' ? 1 : 0]);\n"
"    }\n"
"    return null;\n"
"  }\n"
"\n"
"  function batsJsAddEventListener(nodeId, eventTypePtr, typeLen, listenerId) {\n"
"    const node = nodes.get(nodeId);\n"
"    if (!node) return;\n"
"    const eventType = readString(eventTypePtr, typeLen);\n"
"    const handler = (event) => {\n"
"      currentEvent = event;\n"
"      const payload = encodeEventPayload(event, eventType);\n"
"      if (payload) {\n"
"        const stashId = stashData(payload);\n"
"        instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"      }\n"
"      instance.exports.bats_on_event(listenerId, payload ? payload.length : 0);\n"
"      currentEvent = null;\n"
"    };\n"
"    listenerMap.set(listenerId, { node, eventType, handler });\n"
"    node.addEventListener(eventType, handler);\n"
"  }\n"
"\n"
"  function batsJsRemoveEventListener(listenerId) {\n"
"    const entry = listenerMap.get(listenerId);\n"
"    if (entry) {\n"
"      entry.node.removeEventListener(entry.eventType, entry.handler);\n"
"      listenerMap.delete(listenerId);\n"
"    }\n"
"  }\n"
"\n"
"  function batsJsPreventDefault() {\n"
"    if (currentEvent) currentEvent.preventDefault();\n"
"  }\n"
"\n"
"  // --- Fetch ---\n"
"\n"
"  function batsJsFetch(urlPtr, urlLen, resolverId) {\n"
"    const url = readString(urlPtr, urlLen);\n"
"    fetch(url).then(async (response) => {\n"
"      const body = new Uint8Array(await response.arrayBuffer());\n"
"      if (body.length > 0) {\n"
"        const stashId = stashData(body);\n"
"        instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"      }\n"
"      instance.exports.bats_on_fetch_complete(resolverId, response.status, body.length);\n"
"    }).catch(() => {\n"
"      instance.exports.bats_on_fetch_complete(resolverId, 0, 0);\n"
"    });\n"
"  }\n"
"\n"
"  // --- Clipboard ---\n"
"\n"
"  function batsJsClipboardWriteText(textPtr, textLen, resolverId) {\n"
"    const text = readString(textPtr, textLen);\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      if (win && win.navigator && win.navigator.clipboard) {\n"
"        win.navigator.clipboard.writeText(text).then(\n"
"          () => { instance.exports.bats_on_clipboard_complete(resolverId, 1); },\n"
"          () => { instance.exports.bats_on_clipboard_complete(resolverId, 0); }\n"
"        );\n"
"      } else {\n"
"        instance.exports.bats_on_clipboard_complete(resolverId, 0);\n"
"      }\n"
"    } catch(e) {\n"
"      instance.exports.bats_on_clipboard_complete(resolverId, 0);\n"
"    }\n"
"  }\n"
"\n"
"  // --- File ---\n"
"\n"
"  const fileCache = new Map();\n"
"  let nextFileHandle = 1;\n"
"\n"
"  function batsJsFileOpen(inputNodeId, resolverId) {\n"
"    const el = nodes.get(inputNodeId);\n"
"    if (!el || !el.files || !el.files[0]) {\n"
"      instance.exports.bats_bridge_stash_set_int(2, 0);\n"
"      instance.exports.bats_on_file_open(resolverId, 0, 0);\n"
"      return;\n"
"    }\n"
"    const file = el.files[0];\n"
"    const reader = new FileReader();\n"
"    reader.onload = () => {\n"
"      const handle = nextFileHandle++;\n"
"      const data = new Uint8Array(reader.result);\n"
"      fileCache.set(handle, data);\n"
"      const nameBytes = new TextEncoder().encode(file.name);\n"
"      const nameStashId = stashData(nameBytes);\n"
"      instance.exports.bats_bridge_stash_set_int(1, nameStashId);\n"
"      instance.exports.bats_bridge_stash_set_int(2, nameBytes.length);\n"
"      instance.exports.bats_on_file_open(resolverId, handle, data.length);\n"
"    };\n"
"    reader.onerror = () => {\n"
"      instance.exports.bats_bridge_stash_set_int(2, 0);\n"
"      instance.exports.bats_on_file_open(resolverId, 0, 0);\n"
"    };\n"
"    reader.readAsArrayBuffer(file);\n"
"  }\n"
"\n"
"  function batsJsFileRead(handle, fileOffset, len, outPtr) {\n"
"    const data = fileCache.get(handle);\n"
"    if (!data) return 0;\n"
"    const available = Math.max(0, data.length - fileOffset);\n"
"    const copyLen = Math.min(len, available);\n"
"    if (copyLen > 0) {\n"
"      new Uint8Array(instance.exports.memory.buffer).set(\n"
"        data.subarray(fileOffset, fileOffset + copyLen), outPtr);\n"
"    }\n"
"    return copyLen;\n"
"  }\n"
"\n"
"  function batsJsFileClose(handle) {\n"
"    fileCache.delete(handle);\n"
"  }\n"
"\n"
"  // --- Decompress ---\n"
"\n"
"  const blobCache = new Map();\n"
"  let nextBlobHandle = 1;\n"
"\n"
"  function batsJsDecompress(dataPtr, dataLen, method, resolverId) {\n"
"    const compressed = readBytes(dataPtr, dataLen);\n"
"    const formats = ['gzip', 'deflate', 'deflate-raw'];\n"
"    const format = formats[method];\n"
"    if (!format || typeof DecompressionStream === 'undefined') {\n"
"      instance.exports.bats_on_decompress_complete(resolverId, 0, 0);\n"
"      return;\n"
"    }\n"
"    const ds = new DecompressionStream(format);\n"
"    const writer = ds.writable.getWriter();\n"
"    writer.write(compressed);\n"
"    writer.close();\n"
"    const reader = ds.readable.getReader();\n"
"    const chunks = [];\n"
"    (function pump() {\n"
"      reader.read().then(({ done, value }) => {\n"
"        if (value) chunks.push(value);\n"
"        if (done) {\n"
"          let totalLen = 0;\n"
"          for (const c of chunks) totalLen += c.length;\n"
"          const result = new Uint8Array(totalLen);\n"
"          let off = 0;\n"
"          for (const c of chunks) { result.set(c, off); off += c.length; }\n"
"          const handle = nextBlobHandle++;\n"
"          blobCache.set(handle, result);\n"
"          instance.exports.bats_on_decompress_complete(resolverId, handle, result.length);\n"
"        } else {\n"
"          pump();\n"
"        }\n"
"      }).catch(() => {\n"
"        instance.exports.bats_on_decompress_complete(resolverId, 0, 0);\n"
"      });\n"
"    })();\n"
"  }\n"
"\n"
"  function batsJsBlobRead(handle, blobOffset, len, outPtr) {\n"
"    const data = blobCache.get(handle);\n"
"    if (!data) return 0;\n"
"    const available = Math.max(0, data.length - blobOffset);\n"
"    const copyLen = Math.min(len, available);\n"
"    if (copyLen > 0) {\n"
"      new Uint8Array(instance.exports.memory.buffer).set(\n"
"        data.subarray(blobOffset, blobOffset + copyLen), outPtr);\n"
"    }\n"
"    return copyLen;\n"
"  }\n"
"\n"
"  function batsJsBlobFree(handle) {\n"
"    blobCache.delete(handle);\n"
"  }\n"
"\n"
"  // --- Notification/Push ---\n"
"\n"
"  function batsJsNotificationRequestPermission(resolverId) {\n"
"    if (typeof Notification === 'undefined') {\n"
"      instance.exports.bats_on_permission_result(resolverId, 0);\n"
"      return;\n"
"    }\n"
"    Notification.requestPermission().then((perm) => {\n"
"      instance.exports.bats_on_permission_result(resolverId, perm === 'granted' ? 1 : 0);\n"
"    }).catch(() => {\n"
"      instance.exports.bats_on_permission_result(resolverId, 0);\n"
"    });\n"
"  }\n"
"\n"
"  function batsJsNotificationShow(titlePtr, titleLen) {\n"
"    if (typeof Notification === 'undefined') return;\n"
"    const title = readString(titlePtr, titleLen);\n"
"    try { new Notification(title); } catch(e) {}\n"
"  }\n"
"\n"
"  function batsJsPushSubscribe(vapidPtr, vapidLen, resolverId) {\n"
"    try {\n"
"      const vapidBytes = readBytes(vapidPtr, vapidLen);\n"
"      navigator.serviceWorker.ready.then((reg) => {\n"
"        return reg.pushManager.subscribe({\n"
"          userVisibleOnly: true,\n"
"          applicationServerKey: vapidBytes,\n"
"        });\n"
"      }).then((sub) => {\n"
"        const json = JSON.stringify(sub.toJSON());\n"
"        const jsonBytes = new TextEncoder().encode(json);\n"
"        const stashId = stashData(jsonBytes);\n"
"        instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"        instance.exports.bats_on_push_subscribe(resolverId, jsonBytes.length);\n"
"      }).catch(() => {\n"
"        instance.exports.bats_on_push_subscribe(resolverId, 0);\n"
"      });\n"
"    } catch(e) {\n"
"      instance.exports.bats_on_push_subscribe(resolverId, 0);\n"
"    }\n"
"  }\n"
"\n"
"  function batsJsPushGetSubscription(resolverId) {\n"
"    try {\n"
"      navigator.serviceWorker.ready.then((reg) => {\n"
"        return reg.pushManager.getSubscription();\n"
"      }).then((sub) => {\n"
"        if (!sub) {\n"
"          instance.exports.bats_on_push_subscribe(resolverId, 0);\n"
"          return;\n"
"        }\n"
"        const json = JSON.stringify(sub.toJSON());\n"
"        const jsonBytes = new TextEncoder().encode(json);\n"
"        const stashId = stashData(jsonBytes);\n"
"        instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"        instance.exports.bats_on_push_subscribe(resolverId, jsonBytes.length);\n"
"      }).catch(() => {\n"
"        instance.exports.bats_on_push_subscribe(resolverId, 0);\n"
"      });\n"
"    } catch(e) {\n"
"      instance.exports.bats_on_push_subscribe(resolverId, 0);\n"
"    }\n"
"  }\n"
"\n"
"  // --- HTML parsing ---\n"
"\n"
"  // Tags filtered out during parsing (security/sanitization)\n"
"  const FILTERED_TAGS = new Set([\n"
"    'script', 'iframe', 'object', 'embed', 'form', 'input', 'link', 'meta'\n"
"  ]);\n"
"\n"
"  function batsJsParseHtml(htmlPtr, htmlLen) {\n"
"    const html = readString(htmlPtr, htmlLen);\n"
"    let doc;\n"
"    try {\n"
"      const win = root.ownerDocument.defaultView;\n"
"      if (typeof win.DOMParser !== 'undefined') {\n"
"        doc = new win.DOMParser().parseFromString(html, 'text/html');\n"
"      } else {\n"
"        return 0;\n"
"      }\n"
"    } catch(e) { return 0; }\n"
"\n"
"    // Serialize DOM tree to binary SAX format\n"
"    const chunks = [];\n"
"    let totalLen = 0;\n"
"\n"
"    function pushByte(b) { chunks.push(new Uint8Array([b])); totalLen += 1; }\n"
"    function pushU16LE(v) { chunks.push(new Uint8Array([v & 0xFF, (v >> 8) & 0xFF])); totalLen += 2; }\n"
"    function pushBytes(arr) { chunks.push(arr); totalLen += arr.length; }\n"
"\n"
"    function serializeNode(node) {\n"
"      if (node.nodeType === 1) { // ELEMENT_NODE\n"
"        const tag = node.tagName.toLowerCase();\n"
"        if (FILTERED_TAGS.has(tag)) return;\n"
"        const tagBytes = new TextEncoder().encode(tag);\n"
"        if (tagBytes.length > 255) return;\n"
"\n"
"        // Collect safe attributes\n"
"        const attrs = [];\n"
"        for (let i = 0; i < node.attributes.length; i++) {\n"
"          const attr = node.attributes[i];\n"
"          if (/^on/i.test(attr.name)) continue;    // skip event handlers\n"
"          if (attr.name === 'style') continue;       // skip style\n"
"          if (!/^[a-zA-Z0-9-]+$/.test(attr.name)) continue; // skip non-safe names\n"
"          const nameBytes = new TextEncoder().encode(attr.name);\n"
"          const valBytes = new TextEncoder().encode(attr.value);\n"
"          if (nameBytes.length > 255 || valBytes.length > 65535) continue;\n"
"          attrs.push({ nameBytes, valBytes });\n"
"        }\n"
"\n"
"        // ELEMENT_OPEN: [0x01] [u8:tag_len] [bytes:tag] [u8:attr_count]\n"
"        pushByte(0x01);\n"
"        pushByte(tagBytes.length);\n"
"        pushBytes(tagBytes);\n"
"        pushByte(attrs.length);\n"
"\n"
"        // per attr: [u8:name_len] [bytes:name] [u16le:value_len] [bytes:value]\n"
"        for (const a of attrs) {\n"
"          pushByte(a.nameBytes.length);\n"
"          pushBytes(a.nameBytes);\n"
"          pushU16LE(a.valBytes.length);\n"
"          pushBytes(a.valBytes);\n"
"        }\n"
"\n"
"        // Recurse children\n"
"        for (let i = 0; i < node.childNodes.length; i++) {\n"
"          serializeNode(node.childNodes[i]);\n"
"        }\n"
"\n"
"        // ELEMENT_CLOSE: [0x02]\n"
"        pushByte(0x02);\n"
"      } else if (node.nodeType === 3) { // TEXT_NODE\n"
"        const text = node.textContent || '';\n"
"        if (text.length === 0) return;\n"
"        const textBytes = new TextEncoder().encode(text);\n"
"        if (textBytes.length > 65535) return;\n"
"        // TEXT: [0x03] [u16le:text_len] [bytes:text]\n"
"        pushByte(0x03);\n"
"        pushU16LE(textBytes.length);\n"
"        pushBytes(textBytes);\n"
"      }\n"
"    }\n"
"\n"
"    // Serialize body children (skip <html>, <head>, <body> wrappers)\n"
"    const body = doc.body;\n"
"    if (body) {\n"
"      for (let i = 0; i < body.childNodes.length; i++) {\n"
"        serializeNode(body.childNodes[i]);\n"
"      }\n"
"    }\n"
"\n"
"    if (totalLen === 0) return 0;\n"
"\n"
"    // Combine chunks and stash for WASM to pull\n"
"    const combined = new Uint8Array(totalLen);\n"
"    let off = 0;\n"
"    for (const chunk of chunks) {\n"
"      combined.set(chunk, off);\n"
"      off += chunk.length;\n"
"    }\n"
"    const stashId = stashData(combined);\n"
"    instance.exports.bats_bridge_stash_set_int(1, stashId);\n"
"    return totalLen;\n"
"  }\n"
"\n"
"  const imports = {\n"
"    env: {\n"
"      ...extraImports,\n"
"      bats_dom_flush: batsDomFlush,\n"
"      bats_js_set_image_src: batsJsSetImageSrc,\n"
"      bats_set_timer: batsSetTimer,\n"
"      bats_exit: () => { resolveDone(); },\n"
"      // IDB\n"
"      bats_idb_js_put: batsIdbPut,\n"
"      bats_idb_js_get: batsIdbGet,\n"
"      bats_idb_js_delete: batsIdbDelete,\n"
"      // Window\n"
"      bats_js_focus_window: batsJsFocusWindow,\n"
"      bats_js_get_visibility_state: batsJsGetVisibilityState,\n"
"      bats_js_log: batsJsLog,\n"
"      // Navigation\n"
"      bats_js_get_url: batsJsGetUrl,\n"
"      bats_js_get_url_hash: batsJsGetUrlHash,\n"
"      bats_js_set_url_hash: batsJsSetUrlHash,\n"
"      bats_js_replace_state: batsJsReplaceState,\n"
"      bats_js_push_state: batsJsPushState,\n"
"      // DOM read\n"
"      bats_js_measure_node: batsJsMeasureNode,\n"
"      bats_js_query_selector: batsJsQuerySelector,\n"
"      // Event listener\n"
"      bats_js_add_event_listener: batsJsAddEventListener,\n"
"      bats_js_remove_event_listener: batsJsRemoveEventListener,\n"
"      bats_js_prevent_default: batsJsPreventDefault,\n"
"      // Fetch\n"
"      bats_js_fetch: batsJsFetch,\n"
"      // Clipboard\n"
"      bats_js_clipboard_write_text: batsJsClipboardWriteText,\n"
"      // File\n"
"      bats_js_file_open: batsJsFileOpen,\n"
"      bats_js_file_read: batsJsFileRead,\n"
"      bats_js_file_close: batsJsFileClose,\n"
"      // Decompress\n"
"      bats_js_decompress: batsJsDecompress,\n"
"      bats_js_blob_read: batsJsBlobRead,\n"
"      bats_js_blob_free: batsJsBlobFree,\n"
"      // Notification/Push\n"
"      bats_js_notification_request_permission: batsJsNotificationRequestPermission,\n"
"      bats_js_notification_show: batsJsNotificationShow,\n"
"      bats_js_push_subscribe: batsJsPushSubscribe,\n"
"      bats_js_push_get_subscription: batsJsPushGetSubscription,\n"
"      // HTML parsing\n"
"      bats_js_parse_html: batsJsParseHtml,\n"
"      // Data stash\n"
"      bats_js_stash_read: batsJsStashRead,\n"
"    },\n"
"  };\n"
"\n"
"  const result = await WebAssembly.instantiate(wasmBytes, imports);\n"
"  instance = result.instance;\n"
"  instance.exports.bats_node_init(0);\n"
"\n"
"  return { exports: instance.exports, nodes, done };\n"
"}\n"
  ;
}
%}
end
