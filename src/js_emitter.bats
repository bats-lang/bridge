(* js_emitter -- ALL JS-generating functions for the bridge *)
(* Kept in a single file so native code can call produce_bridge *)

#include "share/atspre_staload.hats"

#use builder as B

(* ============================================================
   String builder helpers (visible to lib.bats via module)
   ============================================================ *)

#pub fun emit_js_all(b: !$B.builder): void

fun bput_loop {sn:nat}{i:nat | i <= sn}{fuel:nat} .<fuel>.
  (b: !$B.builder, s: string sn, slen: int sn, i: int i, fuel: int fuel): void =
  if fuel <= 0 then ()
  else if i >= slen then ()
  else let
    val c = char2int0(string_get_at(s, i))
    val () = $B.put_byte(b, c)
  in bput_loop(b, s, slen, i + 1, fuel - 1) end

fn bput {sn:nat} (b: !$B.builder, s: string sn): void = let
  val slen_sz = string1_length(s)
  val slen = g1u2i(slen_sz)
in bput_loop(b, s, slen, 0, slen + 1) end

(* ============================================================
   Per-concept JS emitters
   ============================================================ *)

fn emit_js_header(b: !$B.builder): void = let
  val () = bput(b, "// bats_bridge.mjs — Bridge between bats WASM and a DOM document\n")
  val () = bput(b, "// Parses the bats binary diff protocol and applies it to a standard DOM.\n")
  val () = bput(b, "// Works in any ES module environment (browser or Node.js).\n")
  val () = bput(b, "\n")
  val () = bput(b, "// Parse a little-endian i32 from a Uint8Array at offset\n")
  val () = bput(b, "function readI32(buf, off) {\n")
  val () = bput(b, "  return buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24);\n")
  val () = bput(b, "}\n")
  val () = bput(b, "\n")
  val () = bput(b, "function readU16LE(buf, off) {\n")
  val () = bput(b, "  return buf[off] | (buf[off+1] << 8);\n")
  val () = bput(b, "}\n")
in end

fn emit_js_loadwasm_open(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "/**\n")
  val () = bput(b, " * Load a bats WASM module and connect it to a DOM document.\n")
  val () = bput(b, " *\n")
  val () = bput(b, " * @param {BufferSource} wasmBytes — compiled WASM bytes\n")
  val () = bput(b, " * @param {Element} root — root element for bats to render into (node_id 0)\n")
  val () = bput(b, " * @returns {{ exports, nodes, done }} — WASM exports, node registry,\n")
  val () = bput(b, " *   and a promise that resolves when WASM calls bats_exit\n")
  val () = bput(b, " */\n")
  val () = bput(b, "export async function loadWASM(wasmBytes, root, opts) {\n")
  val () = bput(b, "  const extraImports = (opts && opts.extraImports) || {};\n")
  val () = bput(b, "  const document = root.ownerDocument;\n")
  val () = bput(b, "  let instance = null;\n")
  val () = bput(b, "  let resolveDone;\n")
  val () = bput(b, "  const done = new Promise(r => { resolveDone = r; });\n")
  val () = bput(b, "\n")
  val () = bput(b, "  // Node registry: node_id -> DOM element\n")
  val () = bput(b, "  const nodes = new Map();\n")
  val () = bput(b, "  nodes.set(0, root);\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function readBytes(ptr, len) {\n")
  val () = bput(b, "    return new Uint8Array(instance.exports.memory.buffer, ptr, len).slice();\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function readString(ptr, len) {\n")
  val () = bput(b, "    return new TextDecoder().decode(readBytes(ptr, len));\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  // JS-side data stash — WASM pulls data via bats_js_stash_read\n")
  val () = bput(b, "  const dataStash = new Map();\n")
  val () = bput(b, "  let nextStashId = 0;\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function stashData(data) {\n")
  val () = bput(b, "    const id = nextStashId++;\n")
  val () = bput(b, "    dataStash.set(id, data);\n")
  val () = bput(b, "    return id;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsStashRead(stashId, destPtr, len) {\n")
  val () = bput(b, "    const data = dataStash.get(stashId);\n")
  val () = bput(b, "    if (data) {\n")
  val () = bput(b, "      const copyLen = Math.min(len, data.length);\n")
  val () = bput(b, "      new Uint8Array(instance.exports.memory.buffer).set(\n")
  val () = bput(b, "        data.subarray(0, copyLen), destPtr);\n")
  val () = bput(b, "      dataStash.delete(stashId);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  // Blob URL lifecycle tracking — revoked when element gets new image or is removed\n")
  val () = bput(b, "  const blobUrls = new Map();\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function writeStringToWasm(str, outPtr, maxLen) {\n")
  val () = bput(b, "    const encoded = new TextEncoder().encode(str);\n")
  val () = bput(b, "    const len = Math.min(encoded.length, maxLen);\n")
  val () = bput(b, "    new Uint8Array(instance.exports.memory.buffer).set(encoded.subarray(0, len), outPtr);\n")
  val () = bput(b, "    return len;\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_dom(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- DOM helpers ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function cleanDescendants(parentEl) {\n")
  val () = bput(b, "    for (const [id, node] of nodes) {\n")
  val () = bput(b, "      if (id !== 0 && node !== parentEl && parentEl.contains(node)) {\n")
  val () = bput(b, "        const oldUrl = blobUrls.get(id);\n")
  val () = bput(b, "        if (oldUrl) { URL.revokeObjectURL(oldUrl); blobUrls.delete(id); }\n")
  val () = bput(b, "        nodes.delete(id);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* Canvas context cache *)
  val () = bput(b, "  const ctxCache = new Map();\n")
  val () = bput(b, "  function getCtx(nid) {\n")
  val () = bput(b, "    let ctx = ctxCache.get(nid);\n")
  val () = bput(b, "    if (ctx) return ctx;\n")
  val () = bput(b, "    const el = nodes.get(nid);\n")
  val () = bput(b, "    if (el && el.getContext) { ctx = el.getContext('2d'); ctxCache.set(nid, ctx); return ctx; }\n")
  val () = bput(b, "    return null;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  // --- DOM flush ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsDomFlush(bufPtr, len) {\n")
  val () = bput(b, "    const mem = new Uint8Array(instance.exports.memory.buffer);\n")
  val () = bput(b, "    let pos = 0;\n")
  val () = bput(b, "\n")
  val () = bput(b, "    while (pos < len) {\n")
  val () = bput(b, "      const op = mem[bufPtr + pos];\n")
  val () = bput(b, "      const nodeId = readI32(mem, bufPtr + pos + 1);\n")
  val () = bput(b, "\n")
  val () = bput(b, "      switch (op) {\n")
  val () = bput(b, "        case 4: { // CREATE_ELEMENT\n")
  val () = bput(b, "          const parentId = readI32(mem, bufPtr + pos + 5);\n")
  val () = bput(b, "          const tagLen = mem[bufPtr + pos + 9];\n")
  val () = bput(b, "          const tag = new TextDecoder().decode(mem.slice(bufPtr + pos + 10, bufPtr + pos + 10 + tagLen));\n")
  val () = bput(b, "          const el = document.createElement(tag);\n")
  val () = bput(b, "          nodes.set(nodeId, el);\n")
  val () = bput(b, "          const parent = nodes.get(parentId);\n")
  val () = bput(b, "          if (parent) parent.appendChild(el);\n")
  val () = bput(b, "          pos += 10 + tagLen;\n")
  val () = bput(b, "          break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 1: { // SET_TEXT\n")
  val () = bput(b, "          const textLen = mem[bufPtr + pos + 5] | (mem[bufPtr + pos + 6] << 8);\n")
  val () = bput(b, "          const text = new TextDecoder().decode(mem.slice(bufPtr + pos + 7, bufPtr + pos + 7 + textLen));\n")
  val () = bput(b, "          const el = nodes.get(nodeId);\n")
  val () = bput(b, "          if (el) el.textContent = text;\n")
  val () = bput(b, "          pos += 7 + textLen;\n")
  val () = bput(b, "          break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 2: { // SET_ATTR\n")
  val () = bput(b, "          const nameLen = mem[bufPtr + pos + 5];\n")
  val () = bput(b, "          const name = new TextDecoder().decode(mem.slice(bufPtr + pos + 6, bufPtr + pos + 6 + nameLen));\n")
  val () = bput(b, "          const valOff = pos + 6 + nameLen;\n")
  val () = bput(b, "          const valLen = mem[bufPtr + valOff] | (mem[bufPtr + valOff + 1] << 8);\n")
  val () = bput(b, "          const value = new TextDecoder().decode(mem.slice(bufPtr + valOff + 2, bufPtr + valOff + 2 + valLen));\n")
  val () = bput(b, "          const el = nodes.get(nodeId);\n")
  val () = bput(b, "          if (el) el.setAttribute(name, value);\n")
  val () = bput(b, "          pos += 6 + nameLen + 2 + valLen;\n")
  val () = bput(b, "          break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 3: { // REMOVE_CHILDREN\n")
  val () = bput(b, "          const el = nodes.get(nodeId);\n")
  val () = bput(b, "          if (el) {\n")
  val () = bput(b, "            cleanDescendants(el);\n")
  val () = bput(b, "            el.innerHTML = '';\n")
  val () = bput(b, "          }\n")
  val () = bput(b, "          pos += 5;\n")
  val () = bput(b, "          break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 5: { // REMOVE_CHILD\n")
  val () = bput(b, "          const el = nodes.get(nodeId);\n")
  val () = bput(b, "          if (el) {\n")
  val () = bput(b, "            cleanDescendants(el);\n")
  val () = bput(b, "            el.remove();\n")
  val () = bput(b, "          }\n")
  val () = bput(b, "          const oldUrl = blobUrls.get(nodeId);\n")
  val () = bput(b, "          if (oldUrl) { URL.revokeObjectURL(oldUrl); blobUrls.delete(nodeId); }\n")
  val () = bput(b, "          nodes.delete(nodeId);\n")
  val () = bput(b, "          pos += 5;\n")
  val () = bput(b, "          break;\n")
  val () = bput(b, "        }\n")
  (* Canvas opcodes 64-84 *)
  val () = bput(b, "        case 64: { // CANVAS_FILL_RECT\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9),w=readI32(mem,bufPtr+pos+13),h=readI32(mem,bufPtr+pos+17);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.fillRect(x,y,w,h);\n")
  val () = bput(b, "          pos+=21; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 65: { // CANVAS_STROKE_RECT\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9),w=readI32(mem,bufPtr+pos+13),h=readI32(mem,bufPtr+pos+17);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.strokeRect(x,y,w,h);\n")
  val () = bput(b, "          pos+=21; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 66: { // CANVAS_CLEAR_RECT\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9),w=readI32(mem,bufPtr+pos+13),h=readI32(mem,bufPtr+pos+17);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.clearRect(x,y,w,h);\n")
  val () = bput(b, "          pos+=21; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 67: { // CANVAS_BEGIN_PATH\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.beginPath();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 68: { // CANVAS_MOVE_TO\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.moveTo(x,y);\n")
  val () = bput(b, "          pos+=13; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 69: { // CANVAS_LINE_TO\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.lineTo(x,y);\n")
  val () = bput(b, "          pos+=13; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 70: { // CANVAS_ARC\n")
  val () = bput(b, "          const cx=readI32(mem,bufPtr+pos+5),cy=readI32(mem,bufPtr+pos+9),r=readI32(mem,bufPtr+pos+13);\n")
  val () = bput(b, "          const s1000=readI32(mem,bufPtr+pos+17),e1000=readI32(mem,bufPtr+pos+21);\n")
  val () = bput(b, "          const ccw=mem[bufPtr+pos+25];\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.arc(cx,cy,r,s1000/1000,e1000/1000,ccw!==0);\n")
  val () = bput(b, "          pos+=26; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 71: { // CANVAS_CLOSE_PATH\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.closePath();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 72: { // CANVAS_FILL\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.fill();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 73: { // CANVAS_STROKE\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.stroke();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 74: { // CANVAS_FILL_COLOR\n")
  val () = bput(b, "          const r0=mem[bufPtr+pos+5],g0=mem[bufPtr+pos+6],b0=mem[bufPtr+pos+7],a0=mem[bufPtr+pos+8];\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.fillStyle=`rgba(${r0},${g0},${b0},${a0/255})`;\n")
  val () = bput(b, "          pos+=9; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 75: { // CANVAS_STROKE_COLOR\n")
  val () = bput(b, "          const r0=mem[bufPtr+pos+5],g0=mem[bufPtr+pos+6],b0=mem[bufPtr+pos+7],a0=mem[bufPtr+pos+8];\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.strokeStyle=`rgba(${r0},${g0},${b0},${a0/255})`;\n")
  val () = bput(b, "          pos+=9; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 76: { // CANVAS_LINE_WIDTH\n")
  val () = bput(b, "          const w100=readI32(mem,bufPtr+pos+5);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.lineWidth=w100/100;\n")
  val () = bput(b, "          pos+=9; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 77: { // CANVAS_FILL_TEXT\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const tl=readU16LE(mem,bufPtr+pos+13);\n")
  val () = bput(b, "          const t=new TextDecoder().decode(mem.slice(bufPtr+pos+15,bufPtr+pos+15+tl));\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.fillText(t,x,y);\n")
  val () = bput(b, "          pos+=15+tl; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 78: { // CANVAS_STROKE_TEXT\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const tl=readU16LE(mem,bufPtr+pos+13);\n")
  val () = bput(b, "          const t=new TextDecoder().decode(mem.slice(bufPtr+pos+15,bufPtr+pos+15+tl));\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.strokeText(t,x,y);\n")
  val () = bput(b, "          pos+=15+tl; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 79: { // CANVAS_SET_FONT\n")
  val () = bput(b, "          const fl=readU16LE(mem,bufPtr+pos+5);\n")
  val () = bput(b, "          const f=new TextDecoder().decode(mem.slice(bufPtr+pos+7,bufPtr+pos+7+fl));\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.font=f;\n")
  val () = bput(b, "          pos+=7+fl; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 80: { // CANVAS_SAVE\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.save();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 81: { // CANVAS_RESTORE\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.restore();\n")
  val () = bput(b, "          pos+=5; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 82: { // CANVAS_TRANSLATE\n")
  val () = bput(b, "          const x=readI32(mem,bufPtr+pos+5),y=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.translate(x,y);\n")
  val () = bput(b, "          pos+=13; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 83: { // CANVAS_ROTATE\n")
  val () = bput(b, "          const a1000=readI32(mem,bufPtr+pos+5);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.rotate(a1000/1000);\n")
  val () = bput(b, "          pos+=9; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        case 84: { // CANVAS_SCALE\n")
  val () = bput(b, "          const sx1000=readI32(mem,bufPtr+pos+5),sy1000=readI32(mem,bufPtr+pos+9);\n")
  val () = bput(b, "          const ctx=getCtx(nodeId); if(ctx) ctx.scale(sx1000/1000,sy1000/1000);\n")
  val () = bput(b, "          pos+=13; break;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        default:\n")
  val () = bput(b, "          throw new Error(`Unknown bats DOM op: ${op} at offset ${pos}`);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsSetImageSrc(nodeId, dataPtr, dataLen, mimePtr, mimeLen) {\n")
  val () = bput(b, "    const mime = readString(mimePtr, mimeLen);\n")
  val () = bput(b, "    const bytes = readBytes(dataPtr, dataLen);\n")
  val () = bput(b, "    const oldUrl = blobUrls.get(nodeId);\n")
  val () = bput(b, "    if (oldUrl) URL.revokeObjectURL(oldUrl);\n")
  val () = bput(b, "    const blob = new Blob([bytes], { type: mime });\n")
  val () = bput(b, "    const url = URL.createObjectURL(blob);\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el) el.src = url;\n")
  val () = bput(b, "    blobUrls.set(nodeId, url);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_timer(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Timer ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsSetTimer(delayMs, resolverId) {\n")
  val () = bput(b, "    setTimeout(() => {\n")
  val () = bput(b, "      instance.exports.bats_timer_fire(resolverId);\n")
  val () = bput(b, "    }, delayMs);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_idb(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- IndexedDB ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  let dbPromise = null;\n")
  val () = bput(b, "  function openDB() {\n")
  val () = bput(b, "    if (!dbPromise) {\n")
  val () = bput(b, "      dbPromise = new Promise((resolve, reject) => {\n")
  val () = bput(b, "        const req = indexedDB.open('bats', 1);\n")
  val () = bput(b, "        req.onupgradeneeded = () => {\n")
  val () = bput(b, "          req.result.createObjectStore('kv');\n")
  val () = bput(b, "        };\n")
  val () = bput(b, "        req.onsuccess = () => resolve(req.result);\n")
  val () = bput(b, "        req.onerror = () => reject(req.error);\n")
  val () = bput(b, "      });\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    return dbPromise;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsIdbPut(keyPtr, keyLen, valPtr, valLen, resolverId) {\n")
  val () = bput(b, "    const key = readString(keyPtr, keyLen);\n")
  val () = bput(b, "    const val_ = readBytes(valPtr, valLen);\n")
  val () = bput(b, "    openDB().then(db => {\n")
  val () = bput(b, "      const tx = db.transaction('kv', 'readwrite');\n")
  val () = bput(b, "      tx.objectStore('kv').put(val_, key);\n")
  val () = bput(b, "      tx.oncomplete = () => {\n")
  val () = bput(b, "        instance.exports.bats_idb_fire(resolverId, 0);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "      tx.onerror = () => {\n")
  val () = bput(b, "        instance.exports.bats_idb_fire(resolverId, -1);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsIdbGet(keyPtr, keyLen, resolverId) {\n")
  val () = bput(b, "    const key = readString(keyPtr, keyLen);\n")
  val () = bput(b, "    openDB().then(db => {\n")
  val () = bput(b, "      const tx = db.transaction('kv', 'readonly');\n")
  val () = bput(b, "      const req = tx.objectStore('kv').get(key);\n")
  val () = bput(b, "      req.onsuccess = () => {\n")
  val () = bput(b, "        const result = req.result;\n")
  val () = bput(b, "        if (result === undefined) {\n")
  val () = bput(b, "          instance.exports.bats_idb_fire_get(resolverId, 0);\n")
  val () = bput(b, "        } else {\n")
  val () = bput(b, "          const data = new Uint8Array(result);\n")
  val () = bput(b, "          const stashId = stashData(data);\n")
  val () = bput(b, "          instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "          instance.exports.bats_idb_fire_get(resolverId, data.length);\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "      req.onerror = () => {\n")
  val () = bput(b, "        instance.exports.bats_idb_fire_get(resolverId, 0);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsIdbDelete(keyPtr, keyLen, resolverId) {\n")
  val () = bput(b, "    const key = readString(keyPtr, keyLen);\n")
  val () = bput(b, "    openDB().then(db => {\n")
  val () = bput(b, "      const tx = db.transaction('kv', 'readwrite');\n")
  val () = bput(b, "      tx.objectStore('kv').delete(key);\n")
  val () = bput(b, "      tx.oncomplete = () => {\n")
  val () = bput(b, "        instance.exports.bats_idb_fire(resolverId, 0);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "      tx.onerror = () => {\n")
  val () = bput(b, "        instance.exports.bats_idb_fire(resolverId, -1);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* IDB list keys *)
  val () = bput(b, "  function batsIdbListKeys(prefixPtr, prefixLen, resolverId) {\n")
  val () = bput(b, "    const prefix = readString(prefixPtr, prefixLen);\n")
  val () = bput(b, "    openDB().then(db => {\n")
  val () = bput(b, "      const tx = db.transaction('kv', 'readonly');\n")
  val () = bput(b, "      const req = tx.objectStore('kv').getAllKeys();\n")
  val () = bput(b, "      req.onsuccess = () => {\n")
  val () = bput(b, "        const keys = req.result.filter(k => typeof k === 'string' && k.startsWith(prefix));\n")
  val () = bput(b, "        const chunks = [];\n")
  val () = bput(b, "        let totalLen = 0;\n")
  val () = bput(b, "        for (const k of keys) {\n")
  val () = bput(b, "          const kb = new TextEncoder().encode(k);\n")
  val () = bput(b, "          const hdr = new Uint8Array(2);\n")
  val () = bput(b, "          hdr[0] = kb.length & 0xFF; hdr[1] = (kb.length >> 8) & 0xFF;\n")
  val () = bput(b, "          chunks.push(hdr); chunks.push(kb);\n")
  val () = bput(b, "          totalLen += 2 + kb.length;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        if (totalLen === 0) { instance.exports.bats_idb_fire_get(resolverId, 0); return; }\n")
  val () = bput(b, "        const combined = new Uint8Array(totalLen);\n")
  val () = bput(b, "        let off = 0;\n")
  val () = bput(b, "        for (const c of chunks) { combined.set(c, off); off += c.length; }\n")
  val () = bput(b, "        const stashId = stashData(combined);\n")
  val () = bput(b, "        instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "        instance.exports.bats_idb_fire_get(resolverId, totalLen);\n")
  val () = bput(b, "      };\n")
  val () = bput(b, "      req.onerror = () => { instance.exports.bats_idb_fire_get(resolverId, 0); };\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_window(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Window ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFocusWindow() {\n")
  val () = bput(b, "    try { root.ownerDocument.defaultView.focus(); } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsGetVisibilityState() {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      return document.visibilityState === 'hidden' ? 1 : 0;\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsLog(level, msgPtr, msgLen) {\n")
  val () = bput(b, "    const msg = readString(msgPtr, msgLen);\n")
  val () = bput(b, "    const labels = ['debug', 'info', 'warn', 'error'];\n")
  val () = bput(b, "    const label = labels[level] || 'log';\n")
  val () = bput(b, "    console.log(`[bats:${label}] ${msg}`);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_nav(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Navigation ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsGetUrl(outPtr, maxLen) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      return writeStringToWasm(win.location.href, outPtr, maxLen);\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsGetUrlHash(outPtr, maxLen) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      return writeStringToWasm(win.location.hash, outPtr, maxLen);\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsSetUrlHash(hashPtr, hashLen) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      win.location.hash = readString(hashPtr, hashLen);\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsReplaceState(urlPtr, urlLen) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      win.history.replaceState(null, '', readString(urlPtr, urlLen));\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsPushState(urlPtr, urlLen) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      win.history.pushState(null, '', readString(urlPtr, urlLen));\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_dom_read(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- DOM read ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsMeasureNode(nodeId) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el && typeof el.getBoundingClientRect === 'function') {\n")
  val () = bput(b, "      const rect = el.getBoundingClientRect();\n")
  val () = bput(b, "      instance.exports.bats_measure_set(0, Math.round(rect.x));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(1, Math.round(rect.y));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(2, Math.round(rect.width));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(3, Math.round(rect.height));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(4, el.scrollWidth || 0);\n")
  val () = bput(b, "      instance.exports.bats_measure_set(5, el.scrollHeight || 0);\n")
  val () = bput(b, "      return 1;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    for (let i = 0; i < 6; i++) {\n")
  val () = bput(b, "      instance.exports.bats_measure_set(i, 0);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    return 0;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsQuerySelector(selectorPtr, selectorLen) {\n")
  val () = bput(b, "    const selector = readString(selectorPtr, selectorLen);\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const el = document.querySelector(selector);\n")
  val () = bput(b, "      if (!el) return -1;\n")
  val () = bput(b, "      for (const [id, node] of nodes) {\n")
  val () = bput(b, "        if (node === el) return id;\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      return -1;\n")
  val () = bput(b, "    } catch(e) { return -1; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: caret_position_from_point *)
  val () = bput(b, "  function batsJsCaretPositionFromPoint(x, y) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      if (document.caretPositionFromPoint) {\n")
  val () = bput(b, "        const pos = document.caretPositionFromPoint(x, y);\n")
  val () = bput(b, "        return pos ? pos.offset : -1;\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      if (document.caretRangeFromPoint) {\n")
  val () = bput(b, "        const range = document.caretRangeFromPoint(x, y);\n")
  val () = bput(b, "        return range ? range.startOffset : -1;\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      return -1;\n")
  val () = bput(b, "    } catch(e) { return -1; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: read_text_content *)
  val () = bput(b, "  function batsJsReadTextContent(nodeId) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (!el) return 0;\n")
  val () = bput(b, "    const text = el.textContent || '';\n")
  val () = bput(b, "    const bytes = new TextEncoder().encode(text);\n")
  val () = bput(b, "    if (bytes.length === 0) return 0;\n")
  val () = bput(b, "    const stashId = stashData(bytes);\n")
  val () = bput(b, "    instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "    return bytes.length;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: measure_text_offset *)
  val () = bput(b, "  function batsJsMeasureTextOffset(nodeId, offset) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (!el || !el.firstChild) return -1;\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const range = document.createRange();\n")
  val () = bput(b, "      const textNode = el.firstChild;\n")
  val () = bput(b, "      const clampOff = Math.min(offset, (textNode.textContent || '').length);\n")
  val () = bput(b, "      range.setStart(textNode, clampOff);\n")
  val () = bput(b, "      range.collapse(true);\n")
  val () = bput(b, "      const rect = range.getBoundingClientRect();\n")
  val () = bput(b, "      instance.exports.bats_measure_set(0, Math.round(rect.x));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(1, Math.round(rect.y));\n")
  val () = bput(b, "      return 1;\n")
  val () = bput(b, "    } catch(e) { return -1; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: get_selection_text *)
  val () = bput(b, "  function batsJsGetSelectionText() {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const sel = root.ownerDocument.defaultView.getSelection();\n")
  val () = bput(b, "      if (!sel || sel.isCollapsed) return 0;\n")
  val () = bput(b, "      const text = sel.toString();\n")
  val () = bput(b, "      const bytes = new TextEncoder().encode(text);\n")
  val () = bput(b, "      if (bytes.length === 0) return 0;\n")
  val () = bput(b, "      const stashId = stashData(bytes);\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "      return bytes.length;\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: get_selection_rect *)
  val () = bput(b, "  function batsJsGetSelectionRect() {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const sel = root.ownerDocument.defaultView.getSelection();\n")
  val () = bput(b, "      if (!sel || sel.rangeCount === 0) return;\n")
  val () = bput(b, "      const rect = sel.getRangeAt(0).getBoundingClientRect();\n")
  val () = bput(b, "      instance.exports.bats_measure_set(0, Math.round(rect.x));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(1, Math.round(rect.y));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(2, Math.round(rect.width));\n")
  val () = bput(b, "      instance.exports.bats_measure_set(3, Math.round(rect.height));\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: get_selection_range *)
  val () = bput(b, "  function batsJsGetSelectionRange() {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const sel = root.ownerDocument.defaultView.getSelection();\n")
  val () = bput(b, "      if (!sel || sel.rangeCount === 0) return;\n")
  val () = bput(b, "      const range = sel.getRangeAt(0);\n")
  val () = bput(b, "      instance.exports.bats_measure_set(0, range.startOffset);\n")
  val () = bput(b, "      instance.exports.bats_measure_set(1, range.endOffset);\n")
  val () = bput(b, "      let startNid = -1, endNid = -1;\n")
  val () = bput(b, "      for (const [id, node] of nodes) {\n")
  val () = bput(b, "        if (node === range.startContainer || node === range.startContainer.parentNode) startNid = id;\n")
  val () = bput(b, "        if (node === range.endContainer || node === range.endContainer.parentNode) endNid = id;\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      instance.exports.bats_measure_set(2, startNid);\n")
  val () = bput(b, "      instance.exports.bats_measure_set(3, endNid);\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_event(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Event listener ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  const listenerMap = new Map();\n")
  val () = bput(b, "  let currentEvent = null;\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function encodeEventPayload(event, eventType) {\n")
  val () = bput(b, "    if (eventType === 'click' || eventType === 'pointerdown' ||\n")
  val () = bput(b, "        eventType === 'pointerup' || eventType === 'pointermove') {\n")
  val () = bput(b, "      const buf = new ArrayBuffer(20);\n")
  val () = bput(b, "      const dv = new DataView(buf);\n")
  val () = bput(b, "      dv.setFloat64(0, event.clientX || 0, true);\n")
  val () = bput(b, "      dv.setFloat64(8, event.clientY || 0, true);\n")
  val () = bput(b, "      let targetId = -1;\n")
  val () = bput(b, "      if (event.target) {\n")
  val () = bput(b, "        for (const [id, node] of nodes) {\n")
  val () = bput(b, "          if (node === event.target) { targetId = id; break; }\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      dv.setInt32(16, targetId, true);\n")
  val () = bput(b, "      return new Uint8Array(buf);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'keydown' || eventType === 'keyup') {\n")
  val () = bput(b, "      const key = event.key || '';\n")
  val () = bput(b, "      const keyBytes = new TextEncoder().encode(key);\n")
  val () = bput(b, "      const buf = new Uint8Array(1 + keyBytes.length + 1);\n")
  val () = bput(b, "      buf[0] = keyBytes.length;\n")
  val () = bput(b, "      buf.set(keyBytes, 1);\n")
  val () = bput(b, "      const flags = (event.shiftKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) |\n")
  val () = bput(b, "                    (event.altKey ? 4 : 0) | (event.metaKey ? 8 : 0);\n")
  val () = bput(b, "      buf[1 + keyBytes.length] = flags;\n")
  val () = bput(b, "      return buf;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'input') {\n")
  val () = bput(b, "      const value = (event.target && event.target.value) || '';\n")
  val () = bput(b, "      const valBytes = new TextEncoder().encode(value);\n")
  val () = bput(b, "      const buf = new Uint8Array(2 + valBytes.length);\n")
  val () = bput(b, "      buf[0] = valBytes.length & 0xFF;\n")
  val () = bput(b, "      buf[1] = (valBytes.length >> 8) & 0xFF;\n")
  val () = bput(b, "      buf.set(valBytes, 2);\n")
  val () = bput(b, "      return buf;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'scroll') {\n")
  val () = bput(b, "      const buf = new ArrayBuffer(16);\n")
  val () = bput(b, "      const dv = new DataView(buf);\n")
  val () = bput(b, "      const target = event.target || {};\n")
  val () = bput(b, "      dv.setFloat64(0, target.scrollTop || 0, true);\n")
  val () = bput(b, "      dv.setFloat64(8, target.scrollLeft || 0, true);\n")
  val () = bput(b, "      return new Uint8Array(buf);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'resize') {\n")
  val () = bput(b, "      const buf = new ArrayBuffer(16);\n")
  val () = bput(b, "      const dv = new DataView(buf);\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView || {};\n")
  val () = bput(b, "      dv.setFloat64(0, win.innerWidth || 0, true);\n")
  val () = bput(b, "      dv.setFloat64(8, win.innerHeight || 0, true);\n")
  val () = bput(b, "      return new Uint8Array(buf);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'touchstart' || eventType === 'touchend' || eventType === 'touchmove') {\n")
  val () = bput(b, "      const touch = (event.touches && event.touches[0]) ||\n")
  val () = bput(b, "                    (event.changedTouches && event.changedTouches[0]);\n")
  val () = bput(b, "      if (touch) {\n")
  val () = bput(b, "        const buf = new ArrayBuffer(20);\n")
  val () = bput(b, "        const dv = new DataView(buf);\n")
  val () = bput(b, "        dv.setFloat64(0, touch.clientX || 0, true);\n")
  val () = bput(b, "        dv.setFloat64(8, touch.clientY || 0, true);\n")
  val () = bput(b, "        dv.setInt32(16, touch.identifier || 0, true);\n")
  val () = bput(b, "        return new Uint8Array(buf);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      return null;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    if (eventType === 'visibilitychange') {\n")
  val () = bput(b, "      return new Uint8Array([document.visibilityState === 'hidden' ? 1 : 0]);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    return null;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFireEvent(listenerId, event, eventType) {\n")
  val () = bput(b, "    currentEvent = event;\n")
  val () = bput(b, "    const payload = encodeEventPayload(event, eventType);\n")
  val () = bput(b, "    if (payload) {\n")
  val () = bput(b, "      const stashId = stashData(payload);\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    instance.exports.bats_on_event(listenerId, payload ? payload.length : 0);\n")
  val () = bput(b, "    currentEvent = null;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsAddEventListener(nodeId, eventTypePtr, typeLen, listenerId) {\n")
  val () = bput(b, "    const node = nodes.get(nodeId);\n")
  val () = bput(b, "    if (!node) return;\n")
  val () = bput(b, "    const eventType = readString(eventTypePtr, typeLen);\n")
  val () = bput(b, "    const handler = (event) => batsJsFireEvent(listenerId, event, eventType);\n")
  val () = bput(b, "    listenerMap.set(listenerId, { node, eventType, handler });\n")
  val () = bput(b, "    node.addEventListener(eventType, handler);\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: listen on document *)
  val () = bput(b, "  function batsJsAddDocumentListener(eventTypePtr, typeLen, listenerId) {\n")
  val () = bput(b, "    const eventType = readString(eventTypePtr, typeLen);\n")
  val () = bput(b, "    const handler = (event) => batsJsFireEvent(listenerId, event, eventType);\n")
  val () = bput(b, "    listenerMap.set(listenerId, { node: document, eventType, handler });\n")
  val () = bput(b, "    document.addEventListener(eventType, handler);\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsRemoveEventListener(listenerId) {\n")
  val () = bput(b, "    const entry = listenerMap.get(listenerId);\n")
  val () = bput(b, "    if (entry) {\n")
  val () = bput(b, "      entry.node.removeEventListener(entry.eventType, entry.handler);\n")
  val () = bput(b, "      listenerMap.delete(listenerId);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsPreventDefault() {\n")
  val () = bput(b, "    if (currentEvent) currentEvent.preventDefault();\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_fetch(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Fetch ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFetch(urlPtr, urlLen, resolverId) {\n")
  val () = bput(b, "    const url = readString(urlPtr, urlLen);\n")
  val () = bput(b, "    fetch(url).then(async (response) => {\n")
  val () = bput(b, "      const body = new Uint8Array(await response.arrayBuffer());\n")
  val () = bput(b, "      if (body.length > 0) {\n")
  val () = bput(b, "        const stashId = stashData(body);\n")
  val () = bput(b, "        instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "      instance.exports.bats_on_fetch_complete(resolverId, response.status, body.length);\n")
  val () = bput(b, "    }).catch(() => {\n")
  val () = bput(b, "      instance.exports.bats_on_fetch_complete(resolverId, 0, 0);\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_clipboard(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Clipboard ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsClipboardWriteText(textPtr, textLen, resolverId) {\n")
  val () = bput(b, "    const text = readString(textPtr, textLen);\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      if (win && win.navigator && win.navigator.clipboard) {\n")
  val () = bput(b, "        win.navigator.clipboard.writeText(text).then(\n")
  val () = bput(b, "          () => { instance.exports.bats_on_clipboard_complete(resolverId, 1); },\n")
  val () = bput(b, "          () => { instance.exports.bats_on_clipboard_complete(resolverId, 0); }\n")
  val () = bput(b, "        );\n")
  val () = bput(b, "      } else {\n")
  val () = bput(b, "        instance.exports.bats_on_clipboard_complete(resolverId, 0);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    } catch(e) {\n")
  val () = bput(b, "      instance.exports.bats_on_clipboard_complete(resolverId, 0);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  (* New: clipboard read *)
  val () = bput(b, "  function batsJsClipboardReadText(resolverId) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      if (win && win.navigator && win.navigator.clipboard) {\n")
  val () = bput(b, "        win.navigator.clipboard.readText().then(\n")
  val () = bput(b, "          (text) => {\n")
  val () = bput(b, "            const bytes = new TextEncoder().encode(text);\n")
  val () = bput(b, "            if (bytes.length > 0) {\n")
  val () = bput(b, "              const stashId = stashData(bytes);\n")
  val () = bput(b, "              instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "            }\n")
  val () = bput(b, "            instance.exports.bats_on_clipboard_read_complete(resolverId, bytes.length);\n")
  val () = bput(b, "          },\n")
  val () = bput(b, "          () => { instance.exports.bats_on_clipboard_read_complete(resolverId, 0); }\n")
  val () = bput(b, "        );\n")
  val () = bput(b, "      } else {\n")
  val () = bput(b, "        instance.exports.bats_on_clipboard_read_complete(resolverId, 0);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    } catch(e) {\n")
  val () = bput(b, "      instance.exports.bats_on_clipboard_read_complete(resolverId, 0);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_file(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- File ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  const fileCache = new Map();\n")
  val () = bput(b, "  let nextFileHandle = 1;\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFileOpen(inputNodeId, resolverId) {\n")
  val () = bput(b, "    const el = nodes.get(inputNodeId);\n")
  val () = bput(b, "    if (!el || !el.files || !el.files[0]) {\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(2, 0);\n")
  val () = bput(b, "      instance.exports.bats_on_file_open(resolverId, 0, 0);\n")
  val () = bput(b, "      return;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    const file = el.files[0];\n")
  val () = bput(b, "    const reader = new FileReader();\n")
  val () = bput(b, "    reader.onload = () => {\n")
  val () = bput(b, "      const handle = nextFileHandle++;\n")
  val () = bput(b, "      const data = new Uint8Array(reader.result);\n")
  val () = bput(b, "      fileCache.set(handle, data);\n")
  val () = bput(b, "      const nameBytes = new TextEncoder().encode(file.name);\n")
  val () = bput(b, "      const nameStashId = stashData(nameBytes);\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(1, nameStashId);\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(2, nameBytes.length);\n")
  val () = bput(b, "      instance.exports.bats_on_file_open(resolverId, handle, data.length);\n")
  val () = bput(b, "    };\n")
  val () = bput(b, "    reader.onerror = () => {\n")
  val () = bput(b, "      instance.exports.bats_bridge_stash_set_int(2, 0);\n")
  val () = bput(b, "      instance.exports.bats_on_file_open(resolverId, 0, 0);\n")
  val () = bput(b, "    };\n")
  val () = bput(b, "    reader.readAsArrayBuffer(file);\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFileRead(handle, fileOffset, len, outPtr) {\n")
  val () = bput(b, "    const data = fileCache.get(handle);\n")
  val () = bput(b, "    if (!data) return 0;\n")
  val () = bput(b, "    const available = Math.max(0, data.length - fileOffset);\n")
  val () = bput(b, "    const copyLen = Math.min(len, available);\n")
  val () = bput(b, "    if (copyLen > 0) {\n")
  val () = bput(b, "      new Uint8Array(instance.exports.memory.buffer).set(\n")
  val () = bput(b, "        data.subarray(fileOffset, fileOffset + copyLen), outPtr);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    return copyLen;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsFileClose(handle) {\n")
  val () = bput(b, "    fileCache.delete(handle);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_decompress(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Decompress ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  const blobCache = new Map();\n")
  val () = bput(b, "  let nextBlobHandle = 1;\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsDecompress(dataPtr, dataLen, method, resolverId) {\n")
  val () = bput(b, "    const compressed = readBytes(dataPtr, dataLen);\n")
  val () = bput(b, "    const formats = ['gzip', 'deflate', 'deflate-raw'];\n")
  val () = bput(b, "    const format = formats[method];\n")
  val () = bput(b, "    if (!format || typeof DecompressionStream === 'undefined') {\n")
  val () = bput(b, "      instance.exports.bats_on_decompress_complete(resolverId, 0, 0);\n")
  val () = bput(b, "      return;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    const ds = new DecompressionStream(format);\n")
  val () = bput(b, "    const writer = ds.writable.getWriter();\n")
  val () = bput(b, "    writer.write(compressed);\n")
  val () = bput(b, "    writer.close();\n")
  val () = bput(b, "    const reader = ds.readable.getReader();\n")
  val () = bput(b, "    const chunks = [];\n")
  val () = bput(b, "    (function pump() {\n")
  val () = bput(b, "      reader.read().then(({ done, value }) => {\n")
  val () = bput(b, "        if (value) chunks.push(value);\n")
  val () = bput(b, "        if (done) {\n")
  val () = bput(b, "          let totalLen = 0;\n")
  val () = bput(b, "          for (const c of chunks) totalLen += c.length;\n")
  val () = bput(b, "          const result = new Uint8Array(totalLen);\n")
  val () = bput(b, "          let off = 0;\n")
  val () = bput(b, "          for (const c of chunks) { result.set(c, off); off += c.length; }\n")
  val () = bput(b, "          const handle = nextBlobHandle++;\n")
  val () = bput(b, "          blobCache.set(handle, result);\n")
  val () = bput(b, "          instance.exports.bats_on_decompress_complete(resolverId, handle, result.length);\n")
  val () = bput(b, "        } else {\n")
  val () = bput(b, "          pump();\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "      }).catch(() => {\n")
  val () = bput(b, "        instance.exports.bats_on_decompress_complete(resolverId, 0, 0);\n")
  val () = bput(b, "      });\n")
  val () = bput(b, "    })();\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsBlobRead(handle, blobOffset, len, outPtr) {\n")
  val () = bput(b, "    const data = blobCache.get(handle);\n")
  val () = bput(b, "    if (!data) return 0;\n")
  val () = bput(b, "    const available = Math.max(0, data.length - blobOffset);\n")
  val () = bput(b, "    const copyLen = Math.min(len, available);\n")
  val () = bput(b, "    if (copyLen > 0) {\n")
  val () = bput(b, "      new Uint8Array(instance.exports.memory.buffer).set(\n")
  val () = bput(b, "        data.subarray(blobOffset, blobOffset + copyLen), outPtr);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    return copyLen;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsBlobFree(handle) {\n")
  val () = bput(b, "    blobCache.delete(handle);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_notify(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Notification/Push ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsNotificationRequestPermission(resolverId) {\n")
  val () = bput(b, "    if (typeof Notification === 'undefined') {\n")
  val () = bput(b, "      instance.exports.bats_on_permission_result(resolverId, 0);\n")
  val () = bput(b, "      return;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    Notification.requestPermission().then((perm) => {\n")
  val () = bput(b, "      instance.exports.bats_on_permission_result(resolverId, perm === 'granted' ? 1 : 0);\n")
  val () = bput(b, "    }).catch(() => {\n")
  val () = bput(b, "      instance.exports.bats_on_permission_result(resolverId, 0);\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsNotificationShow(titlePtr, titleLen) {\n")
  val () = bput(b, "    if (typeof Notification === 'undefined') return;\n")
  val () = bput(b, "    const title = readString(titlePtr, titleLen);\n")
  val () = bput(b, "    try { new Notification(title); } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsPushSubscribe(vapidPtr, vapidLen, resolverId) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const vapidBytes = readBytes(vapidPtr, vapidLen);\n")
  val () = bput(b, "      navigator.serviceWorker.ready.then((reg) => {\n")
  val () = bput(b, "        return reg.pushManager.subscribe({\n")
  val () = bput(b, "          userVisibleOnly: true,\n")
  val () = bput(b, "          applicationServerKey: vapidBytes,\n")
  val () = bput(b, "        });\n")
  val () = bput(b, "      }).then((sub) => {\n")
  val () = bput(b, "        const json = JSON.stringify(sub.toJSON());\n")
  val () = bput(b, "        const jsonBytes = new TextEncoder().encode(json);\n")
  val () = bput(b, "        const stashId = stashData(jsonBytes);\n")
  val () = bput(b, "        instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "        instance.exports.bats_on_push_subscribe(resolverId, jsonBytes.length);\n")
  val () = bput(b, "      }).catch(() => {\n")
  val () = bput(b, "        instance.exports.bats_on_push_subscribe(resolverId, 0);\n")
  val () = bput(b, "      });\n")
  val () = bput(b, "    } catch(e) {\n")
  val () = bput(b, "      instance.exports.bats_on_push_subscribe(resolverId, 0);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsPushGetSubscription(resolverId) {\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      navigator.serviceWorker.ready.then((reg) => {\n")
  val () = bput(b, "        return reg.pushManager.getSubscription();\n")
  val () = bput(b, "      }).then((sub) => {\n")
  val () = bput(b, "        if (!sub) {\n")
  val () = bput(b, "          instance.exports.bats_on_push_subscribe(resolverId, 0);\n")
  val () = bput(b, "          return;\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "        const json = JSON.stringify(sub.toJSON());\n")
  val () = bput(b, "        const jsonBytes = new TextEncoder().encode(json);\n")
  val () = bput(b, "        const stashId = stashData(jsonBytes);\n")
  val () = bput(b, "        instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "        instance.exports.bats_on_push_subscribe(resolverId, jsonBytes.length);\n")
  val () = bput(b, "      }).catch(() => {\n")
  val () = bput(b, "        instance.exports.bats_on_push_subscribe(resolverId, 0);\n")
  val () = bput(b, "      });\n")
  val () = bput(b, "    } catch(e) {\n")
  val () = bput(b, "      instance.exports.bats_on_push_subscribe(resolverId, 0);\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_xml(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- HTML parsing ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  const FILTERED_TAGS = new Set([\n")
  val () = bput(b, "    'script', 'iframe', 'object', 'embed', 'form', 'input', 'link', 'meta'\n")
  val () = bput(b, "  ]);\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsParseHtml(htmlPtr, htmlLen) {\n")
  val () = bput(b, "    const html = readString(htmlPtr, htmlLen);\n")
  val () = bput(b, "    let doc;\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      if (typeof win.DOMParser !== 'undefined') {\n")
  val () = bput(b, "        doc = new win.DOMParser().parseFromString(html, 'text/html');\n")
  val () = bput(b, "      } else {\n")
  val () = bput(b, "        return 0;\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "\n")
  val () = bput(b, "    const chunks = [];\n")
  val () = bput(b, "    let totalLen = 0;\n")
  val () = bput(b, "\n")
  val () = bput(b, "    function pushByte(b) { chunks.push(new Uint8Array([b])); totalLen += 1; }\n")
  val () = bput(b, "    function pushU16LE(v) { chunks.push(new Uint8Array([v & 0xFF, (v >> 8) & 0xFF])); totalLen += 2; }\n")
  val () = bput(b, "    function pushBytes(arr) { chunks.push(arr); totalLen += arr.length; }\n")
  val () = bput(b, "\n")
  val () = bput(b, "    function serializeNode(node) {\n")
  val () = bput(b, "      if (node.nodeType === 1) {\n")
  val () = bput(b, "        const tag = node.tagName.toLowerCase();\n")
  val () = bput(b, "        if (FILTERED_TAGS.has(tag)) return;\n")
  val () = bput(b, "        const tagBytes = new TextEncoder().encode(tag);\n")
  val () = bput(b, "        if (tagBytes.length > 255) return;\n")
  val () = bput(b, "\n")
  val () = bput(b, "        const attrs = [];\n")
  val () = bput(b, "        for (let i = 0; i < node.attributes.length; i++) {\n")
  val () = bput(b, "          const attr = node.attributes[i];\n")
  val () = bput(b, "          if (/^on/i.test(attr.name)) continue;\n")
  val () = bput(b, "          if (attr.name === 'style') continue;\n")
  val () = bput(b, "          if (!/^[a-zA-Z0-9-]+$/.test(attr.name)) continue;\n")
  val () = bput(b, "          const nameBytes = new TextEncoder().encode(attr.name);\n")
  val () = bput(b, "          const valBytes = new TextEncoder().encode(attr.value);\n")
  val () = bput(b, "          if (nameBytes.length > 255 || valBytes.length > 65535) continue;\n")
  val () = bput(b, "          attrs.push({ nameBytes, valBytes });\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "\n")
  val () = bput(b, "        pushByte(0x01);\n")
  val () = bput(b, "        pushByte(tagBytes.length);\n")
  val () = bput(b, "        pushBytes(tagBytes);\n")
  val () = bput(b, "        pushByte(attrs.length);\n")
  val () = bput(b, "\n")
  val () = bput(b, "        for (const a of attrs) {\n")
  val () = bput(b, "          pushByte(a.nameBytes.length);\n")
  val () = bput(b, "          pushBytes(a.nameBytes);\n")
  val () = bput(b, "          pushU16LE(a.valBytes.length);\n")
  val () = bput(b, "          pushBytes(a.valBytes);\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "\n")
  val () = bput(b, "        for (let i = 0; i < node.childNodes.length; i++) {\n")
  val () = bput(b, "          serializeNode(node.childNodes[i]);\n")
  val () = bput(b, "        }\n")
  val () = bput(b, "\n")
  val () = bput(b, "        pushByte(0x02);\n")
  val () = bput(b, "      } else if (node.nodeType === 3) {\n")
  val () = bput(b, "        const text = node.textContent || '';\n")
  val () = bput(b, "        if (text.length === 0) return;\n")
  val () = bput(b, "        const textBytes = new TextEncoder().encode(text);\n")
  val () = bput(b, "        if (textBytes.length > 65535) return;\n")
  val () = bput(b, "        pushByte(0x03);\n")
  val () = bput(b, "        pushU16LE(textBytes.length);\n")
  val () = bput(b, "        pushBytes(textBytes);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "\n")
  val () = bput(b, "    const body = doc.body;\n")
  val () = bput(b, "    if (body) {\n")
  val () = bput(b, "      for (let i = 0; i < body.childNodes.length; i++) {\n")
  val () = bput(b, "        serializeNode(body.childNodes[i]);\n")
  val () = bput(b, "      }\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "\n")
  val () = bput(b, "    if (totalLen === 0) return 0;\n")
  val () = bput(b, "\n")
  val () = bput(b, "    const combined = new Uint8Array(totalLen);\n")
  val () = bput(b, "    let off = 0;\n")
  val () = bput(b, "    for (const chunk of chunks) {\n")
  val () = bput(b, "      combined.set(chunk, off);\n")
  val () = bput(b, "      off += chunk.length;\n")
  val () = bput(b, "    }\n")
  val () = bput(b, "    const stashId = stashData(combined);\n")
  val () = bput(b, "    instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "    return totalLen;\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_blob(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Blob URLs ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsCreateBlobUrl(dataPtr, dataLen, mimePtr, mimeLen) {\n")
  val () = bput(b, "    const bytes = readBytes(dataPtr, dataLen);\n")
  val () = bput(b, "    const mime = readString(mimePtr, mimeLen);\n")
  val () = bput(b, "    const blob = new Blob([bytes], { type: mime });\n")
  val () = bput(b, "    const url = URL.createObjectURL(blob);\n")
  val () = bput(b, "    const urlBytes = new TextEncoder().encode(url);\n")
  val () = bput(b, "    const stashId = stashData(urlBytes);\n")
  val () = bput(b, "    instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "    return urlBytes.length;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsRevokeBlobUrl(urlPtr, urlLen) {\n")
  val () = bput(b, "    const url = readString(urlPtr, urlLen);\n")
  val () = bput(b, "    try { URL.revokeObjectURL(url); } catch(e) {}\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsDownloadBlob(dataPtr, dataLen, mimePtr, mimeLen, namePtr, nameLen) {\n")
  val () = bput(b, "    const bytes = readBytes(dataPtr, dataLen);\n")
  val () = bput(b, "    const mime = readString(mimePtr, mimeLen);\n")
  val () = bput(b, "    const name = readString(namePtr, nameLen);\n")
  val () = bput(b, "    const blob = new Blob([bytes], { type: mime });\n")
  val () = bput(b, "    const url = URL.createObjectURL(blob);\n")
  val () = bput(b, "    const a = document.createElement('a');\n")
  val () = bput(b, "    a.href = url; a.download = name;\n")
  val () = bput(b, "    document.body.appendChild(a); a.click();\n")
  val () = bput(b, "    document.body.removeChild(a);\n")
  val () = bput(b, "    URL.revokeObjectURL(url);\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_media(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Media queries ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsMatchMedia(queryPtr, queryLen) {\n")
  val () = bput(b, "    const query = readString(queryPtr, queryLen);\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      return win.matchMedia(query).matches ? 1 : 0;\n")
  val () = bput(b, "    } catch(e) { return 0; }\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsListenMedia(queryPtr, queryLen, listenerId) {\n")
  val () = bput(b, "    const query = readString(queryPtr, queryLen);\n")
  val () = bput(b, "    try {\n")
  val () = bput(b, "      const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "      const mql = win.matchMedia(query);\n")
  val () = bput(b, "      mql.addEventListener('change', (e) => {\n")
  val () = bput(b, "        instance.exports.bats_on_media_change(listenerId, e.matches ? 1 : 0);\n")
  val () = bput(b, "      });\n")
  val () = bput(b, "    } catch(e) {}\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_scroll(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  // --- Scroll ---\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsScrollTo(nodeId, x, y) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el) el.scrollTo(x, y);\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsScrollIntoView(nodeId, smooth) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el) el.scrollIntoView({ behavior: smooth ? 'smooth' : 'instant' });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsSetScrollTop(nodeId, value) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el) el.scrollTop = value;\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  function batsJsSetScrollLeft(nodeId, value) {\n")
  val () = bput(b, "    const el = nodes.get(nodeId);\n")
  val () = bput(b, "    if (el) el.scrollLeft = value;\n")
  val () = bput(b, "  }\n")
in end

fn emit_js_imports(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  const imports = {\n")
  val () = bput(b, "    env: {\n")
  val () = bput(b, "      ...extraImports,\n")
  val () = bput(b, "      bats_dom_flush: batsDomFlush,\n")
  val () = bput(b, "      bats_js_set_image_src: batsJsSetImageSrc,\n")
  val () = bput(b, "      bats_set_timer: batsSetTimer,\n")
  val () = bput(b, "      bats_exit: () => { resolveDone(); },\n")
  val () = bput(b, "      // IDB\n")
  val () = bput(b, "      bats_idb_js_put: batsIdbPut,\n")
  val () = bput(b, "      bats_idb_js_get: batsIdbGet,\n")
  val () = bput(b, "      bats_idb_js_delete: batsIdbDelete,\n")
  val () = bput(b, "      bats_idb_js_list_keys: batsIdbListKeys,\n")
  val () = bput(b, "      // Window\n")
  val () = bput(b, "      bats_js_focus_window: batsJsFocusWindow,\n")
  val () = bput(b, "      bats_js_get_visibility_state: batsJsGetVisibilityState,\n")
  val () = bput(b, "      bats_js_log: batsJsLog,\n")
  val () = bput(b, "      // Navigation\n")
  val () = bput(b, "      bats_js_get_url: batsJsGetUrl,\n")
  val () = bput(b, "      bats_js_get_url_hash: batsJsGetUrlHash,\n")
  val () = bput(b, "      bats_js_set_url_hash: batsJsSetUrlHash,\n")
  val () = bput(b, "      bats_js_replace_state: batsJsReplaceState,\n")
  val () = bput(b, "      bats_js_push_state: batsJsPushState,\n")
  val () = bput(b, "      // DOM read\n")
  val () = bput(b, "      bats_js_measure_node: batsJsMeasureNode,\n")
  val () = bput(b, "      bats_js_query_selector: batsJsQuerySelector,\n")
  val () = bput(b, "      bats_js_caret_position_from_point: batsJsCaretPositionFromPoint,\n")
  val () = bput(b, "      bats_js_read_text_content: batsJsReadTextContent,\n")
  val () = bput(b, "      bats_js_measure_text_offset: batsJsMeasureTextOffset,\n")
  val () = bput(b, "      bats_js_get_selection_text: batsJsGetSelectionText,\n")
  val () = bput(b, "      bats_js_get_selection_rect: batsJsGetSelectionRect,\n")
  val () = bput(b, "      bats_js_get_selection_range: batsJsGetSelectionRange,\n")
  val () = bput(b, "      // Event listener\n")
  val () = bput(b, "      bats_js_add_event_listener: batsJsAddEventListener,\n")
  val () = bput(b, "      bats_js_add_document_listener: batsJsAddDocumentListener,\n")
  val () = bput(b, "      bats_js_remove_event_listener: batsJsRemoveEventListener,\n")
  val () = bput(b, "      bats_js_prevent_default: batsJsPreventDefault,\n")
  val () = bput(b, "      // Fetch\n")
  val () = bput(b, "      bats_js_fetch: batsJsFetch,\n")
  val () = bput(b, "      // Clipboard\n")
  val () = bput(b, "      bats_js_clipboard_write_text: batsJsClipboardWriteText,\n")
  val () = bput(b, "      bats_js_clipboard_read_text: batsJsClipboardReadText,\n")
  val () = bput(b, "      // File\n")
  val () = bput(b, "      bats_js_file_open: batsJsFileOpen,\n")
  val () = bput(b, "      bats_js_file_read: batsJsFileRead,\n")
  val () = bput(b, "      bats_js_file_close: batsJsFileClose,\n")
  val () = bput(b, "      // Decompress\n")
  val () = bput(b, "      bats_js_decompress: batsJsDecompress,\n")
  val () = bput(b, "      bats_js_blob_read: batsJsBlobRead,\n")
  val () = bput(b, "      bats_js_blob_free: batsJsBlobFree,\n")
  val () = bput(b, "      // Notification/Push\n")
  val () = bput(b, "      bats_js_notification_request_permission: batsJsNotificationRequestPermission,\n")
  val () = bput(b, "      bats_js_notification_show: batsJsNotificationShow,\n")
  val () = bput(b, "      bats_js_push_subscribe: batsJsPushSubscribe,\n")
  val () = bput(b, "      bats_js_push_get_subscription: batsJsPushGetSubscription,\n")
  val () = bput(b, "      // HTML parsing\n")
  val () = bput(b, "      bats_js_parse_html: batsJsParseHtml,\n")
  val () = bput(b, "      // Blob URLs\n")
  val () = bput(b, "      bats_js_create_blob_url: batsJsCreateBlobUrl,\n")
  val () = bput(b, "      bats_js_revoke_blob_url: batsJsRevokeBlobUrl,\n")
  val () = bput(b, "      bats_js_download_blob: batsJsDownloadBlob,\n")
  val () = bput(b, "      // Media queries\n")
  val () = bput(b, "      bats_js_match_media: batsJsMatchMedia,\n")
  val () = bput(b, "      bats_js_listen_media: batsJsListenMedia,\n")
  val () = bput(b, "      // Scroll\n")
  val () = bput(b, "      bats_js_scroll_to: batsJsScrollTo,\n")
  val () = bput(b, "      bats_js_scroll_into_view: batsJsScrollIntoView,\n")
  val () = bput(b, "      bats_js_set_scroll_top: batsJsSetScrollTop,\n")
  val () = bput(b, "      bats_js_set_scroll_left: batsJsSetScrollLeft,\n")
  val () = bput(b, "      // Data stash\n")
  val () = bput(b, "      bats_js_stash_read: batsJsStashRead,\n")
  val () = bput(b, "    },\n")
  val () = bput(b, "  };\n")
in end

fn emit_js_loadwasm_close(b: !$B.builder): void = let
  val () = bput(b, "\n")
  val () = bput(b, "  const result = await WebAssembly.instantiate(wasmBytes, imports);\n")
  val () = bput(b, "  instance = result.instance;\n")
  val () = bput(b, "  instance.exports.bats_node_init(0);\n")
  val () = bput(b, "\n")
  val () = bput(b, "  // Listen for browser back/forward navigation\n")
  val () = bput(b, "  const win = root.ownerDocument.defaultView;\n")
  val () = bput(b, "  if (win) {\n")
  val () = bput(b, "    win.addEventListener('popstate', () => {\n")
  val () = bput(b, "      try {\n")
  val () = bput(b, "        const url = win.location.pathname + win.location.search + win.location.hash;\n")
  val () = bput(b, "        const encoded = new TextEncoder().encode(url);\n")
  val () = bput(b, "        const stashId = stashData(encoded);\n")
  val () = bput(b, "        instance.exports.bats_bridge_stash_set_int(1, stashId);\n")
  val () = bput(b, "        instance.exports.bats_on_popstate(encoded.length);\n")
  val () = bput(b, "      } catch(e) {}\n")
  val () = bput(b, "    });\n")
  val () = bput(b, "  }\n")
  val () = bput(b, "\n")
  val () = bput(b, "  return { exports: instance.exports, nodes, done };\n")
  val () = bput(b, "}\n")
in end

(* ============================================================
   Main entry point: emit all JS sections
   ============================================================ *)

implement emit_js_all(b) = let
  val () = emit_js_header(b)
  val () = emit_js_loadwasm_open(b)
  val () = emit_js_dom(b)
  val () = emit_js_timer(b)
  val () = emit_js_idb(b)
  val () = emit_js_window(b)
  val () = emit_js_nav(b)
  val () = emit_js_dom_read(b)
  val () = emit_js_event(b)
  val () = emit_js_fetch(b)
  val () = emit_js_clipboard(b)
  val () = emit_js_file(b)
  val () = emit_js_decompress(b)
  val () = emit_js_notify(b)
  val () = emit_js_xml(b)
  val () = emit_js_blob(b)
  val () = emit_js_media(b)
  val () = emit_js_scroll(b)
  val () = emit_js_imports(b)
  val () = emit_js_loadwasm_close(b)
in end
